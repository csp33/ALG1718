\documentclass[12pt,spanish]{article}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{texdraw}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage[hidelinks]{hyperref}
\usepackage{caption}
\usepackage{multicol}
\usepackage[outputdir=build]{minted}
\usepackage[skins,minted,breakable]{tcolorbox}
\usepackage{float}
\usepackage{array}
\graphicspath{ {../img/} {../../LaTeX/img/} {/home/csp98/latex/img/}}
\selectlanguage{spanish}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\newtheorem{ppio}{Principio }
\makeindex

\begin{document}
\begin{titlepage}

\newlength{\centeroffset}
\setlength{\centeroffset}{-0.5\oddsidemargin}
\addtolength{\centeroffset}{0.5\evensidemargin}
\thispagestyle{empty}

\noindent\hspace*{\centeroffset}
\begin{minipage}{\textwidth}

\centering
\includegraphics[width=0.9\textwidth]{logo_ugr.jpg}\\[1.4cm]

\textsc{ \Large Algorítmica\\[0.2cm]}
\textsc{GRADO EN INGENIERÍA INFORMÁTICA}\\[1cm]

{\Huge\bfseries Práctica 2\\}
\noindent\rule[-1ex]{\textwidth}{3pt}\\[3.5ex]
{\large\bfseries El elemento en su posición}
\end{minipage}

\vspace{1.5cm}
\noindent\hspace*{\centeroffset}
\begin{minipage}{\textwidth}
\centering

\textbf{Autores}\\ {María Jesús López Salmerón \\ Nazaret Román Guerrero \\ Laura Hernández Muñoz \\ José Baena Cobos  \\ Carlos Sánchez Páez}\\[2.5ex]
\includegraphics[width=0.3\textwidth]{etsiit_logo.png}\\[0.1cm]
\vspace{1.5cm}
\includegraphics[width=0.5\textwidth]{decsai.jpg}\\[0.1cm]
\vspace{1cm}
\textsc{Escuela Técnica Superior de Ingenierías Informática y de Telecomunicación}\\
\vspace{1cm}
\textsc{Curso 2017-2018}
\end{minipage}
\end{titlepage}
\tableofcontents
\thispagestyle{empty}
\listoffigures
\newpage
\setcounter{page}{1}
%%%%%%%%%%%%%%%%%%%%%%%%Comienzo del documento%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Descripción de la práctica}

El objetivo de esta práctica es diseñar un algoritmo para resolver el problema del \textit{elemento en su posición}. Este algoritmo consiste en lo siguiente:
\begin{center}
Dado un vector $v$, determinar si $\exists i : v[i]=i $
\end{center}
Se implementarán dos versiones de este algoritmo: una siguiendo el algoritmo obvio y otra empleando la estrategia \emph{Divide y Vencerás}. \\

Para calcular el tiempo de ejecución, cada algoritmo se ejecutará mil veces y nos quedaremos con el tiempo promedio para rebajar el impacto sobre el tiempo de factores externos como la carga del sistema. Para estudiar la eficiencia, ejecutaremos cada código 25 veces con tamaños variables dependiendo de su orden de eficiencia. \\
Para generar los vectores, utilizaremos el generador disponible en \textit{decsai.ugr.es}.

\section{Algoritmos diseñados}

\begin{figure}[H]
\begin{minted}[linenos]{c++}
int elementoEnSuPosicion(const vector<int> v) {
	for (int i = 0; i < v.size() ; i++)
		if (v[i] == i)
			return i;
	return -1;
}
\end{minted}
\caption{Algoritmo clásico}
\label{alg:clasico}
\end{figure}

\begin{figure}[H]
\begin{minted}[linenos]{c++}
int elementoEnSuPosicion(const vector<int> v, const int ini, const int fin) {
	if (ini == fin) {	//Caso base, vector de un solo elemento
		if (v[ini] == ini)
			return ini;
		else
			return -1;
	}
	else {	//Dividimos en dos el vector y llamamos recursivamente
		int mitad = (ini + fin) / 2;
		int pos_izq = elementoEnSuPosicion(v, ini, mitad);
		int pos_dcha = elementoEnSuPosicion(v, mitad + 1, fin);
		if (pos_izq != -1)
			return pos_izq;
		else
			return pos_dcha;
	}
}	
\end{minted}
\caption{Algoritmo Divide y Vencerás}
\label{alg:dyv}
\end{figure}

\begin{figure}[H]
\begin{minted}[linenos]{c++}
	int pos;
	for (int i = 0; i < 1000; i++) {
		tantes = high_resolution_clock::now();
		pos = elementoEnSuPosicion(myvector);
		tdespues = high_resolution_clock::now();
		tiempo = duration_cast<duration<double>>
		         (tdespues - tantes);
		acumulado += tiempo.count();
	}
	acumulado /= 1000;
\end{minted}
\caption{Medición de tiempos}
\end{figure}

\newpage

\section{Estudio de eficiencia}

En esta sección procederemos a estudiar la eficiencia de los algoritmos en cuestión.

\subsection{Eficiencia teórica}

Como podemos ver en \textcolor{blue!60}{\hyperref[alg:clasico]{el algoritmo clásico}}, iteramos por el bucle hasta encontrar un elemento en el que se cumpla la condición ($v[i]=i$). Por tanto, en el peor de los casos recorreremos el bucle completo, siendo la eficiencia de \textbf{O(n)}.\\

En cuanto al \textcolor{blue!60}{\hyperref[alg:clasico]{algoritmo Divide y Vencerás}}, nuestro algoritmo es recursivo y la metodología que sigue es la siguiente:
\begin{itemize}
	\item \textbf{Caso base}. El vector consta de un solo elemento. Si se cumple que $v[i]=i$, devolvemos \textcolor{blue!90}{la posición}. En caso contrario, devolvemos \textcolor{blue!90}{-1}.
	\item Calculamos la posición del elemento mitad del vector.
	\item Llamamos recursivamente a la función desde el tamaño inicial hasta la mitad y desde la mitad + 1 hasta el final.
	\item Comprobamos si el elemento se encuentra en la mitad izquierda. En caso afirmativo, devolvemos \textcolor{blue!90}{su posición}.
	\item En caso contrario, devolvemos \textcolor{blue!90}{el resultado de aplicar el algoritmo en la mitad derecha}.
\end{itemize}

Como podemos ver, aun así en el peor de los casos tendremos que recorrer el vector en su totalidad, por lo que la eficiencia del algoritmo empleando la estrategia \textit{Divide y Vencerás} es \textbf{O(n)}.\\

Por tanto, podemos adelantar que debido a los costes físicos de la recursión, el algoritmo \emph{clásico} será mejor que el \emph{Divide y Vencerás}.

\subsection{Eficiencia empírica}

Haciendo uso de \textcolor{blue!60}{\hyperref[sec:scripts]{los scripts diseñados}}, ejecutamos los algoritmos con los siguientes tamaños:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Algoritmo}  & \textbf{Tamaño inicial} & \textbf{Tamaño final} & \textbf{Incremento}\\
\hline
Clásico & 1.000.000 & 1.480.000 & 20.000 \\
Divide y Vencerás & 1.000 & 3.400 & 100\\
\hline
\end{tabular}
\caption{Parámetros de ejecución de cada programa}
\end{table}

\begin{figure}[H]
\centering

\includegraphics[scale=0.75]{clasico.png}
\vskip 0.5cm

\begin{tabular}{|c|c|}
\hline
\textbf{Tamaño} & \textbf{Tiempo (s)} \\
\hline
1.000.000 & 0,000819706\\
\hline
1.020.000 & 0,000842275\\
\hline
1.040.000 & 0,00085518\\
\hline
1.060.000 & 0,000869587\\
\hline
1.080.000 & 0,000885716\\
\hline
1.100.000 & 0,000899005\\
\hline
1.120.000 & 0,000922726\\
\hline
1.140.000 & 0,000934545\\
\hline
1.160.000 & 0,000951469\\
\hline
1.180.000 & 0,00096667\\
\hline
1.200.000 & 0,000988998\\
\hline
1.220.000 & 0,000997361\\
\hline
1240000 & 0,00101367\\
\hline
1.260.000 & 0,0010278\\
\hline
1.280.000 & 0,00104895\\
\hline
1.300.000 & 0,00106148\\
\hline
1.320.000 & 0,00108836\\
\hline
1.340.000 & 0,00110376\\
\hline
1.360.000 & 0,00113126\\
\hline
1.380.000 & 0,00110421\\
\hline
1.400.000 & 0,00114935\\
\hline
1.420.000 & 0,00116467\\
\hline
1.440.000 & 0,0011756\\
\hline
1.460.000 & 0,00118976\\
\hline
1.480.000 & 0,00121112\\
\hline

\end{tabular}


\caption{Algoritmo clásico}
\end{figure}


\begin{figure}[H]
\centering

\includegraphics[scale=0.75]{dyv.png}

\vskip 0.5cm

\begin{tabular}{|c|c|}
\hline
\textbf{Tamaño} & \textbf{Tiempo (s)} \\
\hline
1.000 & 0,000551096 \\
\hline
1.100 & 0,000600369 \\
\hline
1.200 & 0,000736414 \\
\hline
1.300 & 0,000889537 \\
\hline
1.400 & 0,00100999 \\
\hline
1.500 & 0,00113876 \\
\hline
1.600 & 0,00129452 \\
\hline
1.700 & 0,00150525 \\
\hline
1.800 & 0,00165492 \\
\hline
1.900 & 0,00180961 \\
\hline
2.000 & 0,00215437 \\
\hline
2.100 & 0,00233609 \\
\hline
2.200 & 0,00252987 \\
\hline
2.300 & 0,00276466 \\
\hline
2.400 & 0,00294883 \\
\hline
2.500 & 0,00332321 \\
\hline
2.600 & 0,00349556 \\
\hline
2.700 & 0,00382512 \\
\hline
2.800 & 0,00405147 \\
\hline
2.900 & 0,00431329 \\
\hline
3.000 & 0,00460976 \\
\hline
3.100 & 0,00493946 \\
\hline
3.200 & 0,00534553 \\
\hline
3.300 & 0,00548893 \\
\hline
3.400 & 0,00605759 \\

\hline
\end{tabular}


\caption{Algoritmo Divide y Vencerás}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Algoritmo clásico} & \textbf{Algoritmo Divide y Vencerás} \\
\hline
0,001009366976743 & 0,002223563169903 \\
\hline
\end{tabular}
\caption{Tiempo medio (s)}
\end{figure}

\subsection{Eficiencia híbrida}

En esta sección ajustaremos los datos obtenidos a las expresiones teóricas obtenidas mediante una regresión con el objetivo de obtener su constante oculta.

\begin{figure}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Algoritmo} & \textbf{Eficiencia teórica} & \textbf{Valor de la constante oculta} & \textbf{Error} \\
\hline
Clásico & O($n$) & 8.19304e-10 &0.1441\% \\
Divide y Vencerás & O($n^2$) & 5.17311e-10 & 0.3221\% \\
\hline
\end{tabular}
\end{figure}

\newpage 

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{hibrida_clasico.png}
\caption{Eficiencia híbrida del algoritmo clásico}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{hibrida_dyv.png}
\caption{Eficiencia híbrida del algoritmo Divide y Vencerás}
\end{figure}

\newpage

\section{Conclusiones}

SI HAY ELEMENTOS REPETIDOS AMBOS SIGUEN FUNCIONANDO
\section{Anexo: scripts auxiliares}
\label{sec:scripts}

\begin{figure}[H]
\begin{minted}[linenos]{bash}
#!/bin/bash
if [ $# -eq 3 ]
then
i="0"
tam=$2
#Primer argumento: programa a ejecutar
#Segundo argumento: tamaño inicial
#Tercer argumento : incremento
while [ $i -lt 25 ]
do
	./$1 $tam >> ./$1.dat
	i=$[$i+1]
	tam=$[$tam+$3]
done
else
echo "Error de argumentos"
fi

\end{minted}
%$
\caption{Script individual}
\end{figure}



\begin{figure}[H]
\begin{minted}[linenos]{bash}
#!/usr/bin/gnuplot

set xlabel "Tamanio del problema"
set ylabel "Tiempo (seg)"
set terminal png size 640,480
set output 'clasico.png'
plot 'clasico.dat' with lines
set output 'dyv.png'
plot 'dyv.dat' with lines
\end{minted}
\caption{Script de gnuplot}
\end{figure}


\begin{figure}[H]
\begin{minted}[linenos]{bash}
#!/bin/bash
	echo "Compilando..."
	g++ -o clasico clasico.cpp -O3 &&
	g++ -o dyv dyv.cpp -O3 &&
	rm -f ./clasico.dat ;
	rm -f ./dyv.dat ;
	echo "Ejecutando algoritmo clásico..." ;
	./individual.sh clasico 1000000 20000;
	echo "Ejecutando algoritmo DyV..." ;
	./individual.sh dyv 1000 100;
	echo "Generando gráficas..." ;
	./gnuplot.sh ;
\end{minted}
\caption{Script conjunto}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%Fin del documento%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
